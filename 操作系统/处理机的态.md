# 处理机的态





## 操作系统的两种状态



### 1.内核态

操作系统的管理程序执行的时候所处的状态，cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序



### 2.用户态

用户程序执行的时候所处的状态，只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取

但是我们写程序的时候，明明访问了外部设备啊？傻子，既然访问了外设，肯定是操作系统帮我们屏蔽了操作啊



## 状态的转换



从用户态如何切换到内核态

1. 系统功能调用，在CPU中的实现称之为**陷阱指令**(Trap Instruction)

   访问操作系统，要求系统提供的某种服务

2. 中断

   比如I/O完成中断

3. 异常

   程序执行过程中，产生了错误状态





### 系统调用

**系统调用**是操作系统的最小功能单位。根据不同的应用场景，不同的Linux发行版本提供的系统调用数量也不尽相同。这些系统调用组成了用户态跟内核态交互的基本**接口**，例如：用户态想要申请一块20K大小的动态内存，在用户态，是调用了malloc方法，但是具体到系统调用层面，就需要brk系统调用，将数据段指针向下偏移



工作流程如下

1. 用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.
2. 用户态程序执行陷阱指令
3. CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问
4. 这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务
5. 系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果



当进程执行系统调用，陷入到内核代码中执行的时候，就称称程序处于内核态中运行，此时处理机处于特权级最高的0级运行，并且，执行的内核代码会使用当前进程的内核栈，每一个进程都有自己的内核栈

当进程执行用户自己的代码的时候，在特权级最低(3级)的用户代码中运行，称其处于用户态

Linux 的系统调用主要有

| Task     | Commands                    |
| :------- | :-------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |



### 库函数

为了屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现，**库函数**就很自然提出来了，它可以对系统调用进行封装，提供简单的基本接口给用户，对于简单的接口，也可以直接访问系统资源

注意，库函数既可能直接提供用户态服务，也可能提供封装时候的内核态服务(比如printf函数封装了write系统调用)



常见的库函数

printf，scanf，fopen，fclose，fgetc，fgets，fprintf，fsacnf，fputc，calloc，free，malloc，realloc，strcat，strchr，strcmp，strcpy，strlen，strstr



### 系统调用和库函数的区别



1. 系统调用通常不可替换，库函数通常可以替换

2. 系统调用提供最小接口，库函数通常提供较为复杂的功能

3. 系统调用属于内核，库函数不属于内核

4. 内核调用一定会返回一个整数值，如果为负数，代表调用失败，库函数并不是一定这样

5. 系统调用运行时间属于系统时间，库函数运行时间属于用户时间

6. 系统调用的开销相对更大

   这个是因为双缓冲技术的实现，用户态和内核态都使用了缓冲技术，对于文件读写来说，调用库函数，可以减少系统调用的次数，不需要进行用户控件和内核控件的上下文切换

7. 系统调用直接依赖于内核，不具备移植性，库函数调用平台移植性较好